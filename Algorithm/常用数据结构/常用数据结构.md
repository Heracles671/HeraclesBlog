>常见算法问题类型：运算、查找、排序、最优决策...  
大 O 表示法：找出 f(n)，使得 T(n)/f(n) 为常量  
如何?     
1.如果运行事件是常数量级，则用常数1表示  
2.只保留时间函数中的最高阶项  
3.如果最高阶项存在，则省去最高阶项前面的系数
# 物理结构
## 顺序存储结构
举例：数组，适合读多写少的场景
## 链式存储结构
举例：链表，适合读少写多的场景
# 逻辑结构
逻辑结构依托物理存储结构来实现
## 线性结构
### 栈
stack（push，pop）先进后出，数组、链表都可实现
### 队列
queue（enqueue，dequeue）先进先出，数组、链表都可实现
### 哈希表
哈希冲突解决：
1. 开放寻址法：ThreadLocal
2. 链表法：HashMap

HashMap.size >= Capacity * LoadFactor 时进行扩容：
1. 重新创建一个Entry空数组，长度是原先的2倍
2. 重新 Hash，遍历原数组，重新分配
## 非线形结构
### 树
树是 n（n>=0）个节点的有限集。当 n = 0 时，称为空树。在任意一个非空树中，有如下特点：
1. 有且仅有一个特定的称为根的节点
2. 当 n > 1 时，其余节点可分为 m（m > 0）个互不相交的有限集，每一个本身又是一棵树，并称为根的子树
#### **二叉树**
每个节点最多有2个孩子节点。

满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，并且所有页子节点都在同一层级

完全二叉树：对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1 到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节 点位置相同，则这个二叉树为完全二叉树。

链式结构：
- 存储数据的data变量
- 指向左孩子的left指针
- 指向右孩子的right指针

数组结构：
- left = parent * 2 + 1
- right = parent * 2 + 2

二叉树的应用：
- 查找：二叉查找树
- 维持相对顺序：二叉排序树

二叉树的遍历：

二叉树树典型的非线性数据结构，遍历时需要把非线性关联的节点转化为一个线性的序列，以不同的方式来遍历，遍历出的序列顺序也不一样。

从节点之间的位置关系的角度来看：
- 前序遍历：根子树、左子树、右子树
- 中序遍历：左子树、根子树、右子树
- 后序遍历：左子树、右子树、根子树
- 层序遍历

从更宏观的角度来看：
- 广度优先遍历（前序遍历、中序遍历、后续遍历）：主要思想是回溯递归
- 深度优先遍历（层序遍历）：主要思想是队列

主要遍历方式分为递归和非递归，递归有个特点，就是函数会不停入栈，并保存环境变量；非递归借助栈结构来实现，其实核心思想还是递归
#### **二叉堆**
二叉堆本质上是一种完全二叉树：
1. 最大堆：任何一个父节点的值都大于或等于左右孩子节点
2. 最小堆：任何一个父节点的值都小于或等于左右孩子节点

对于二叉堆，有如下操作：
1. 插入节点：插入位置是完全二叉树的最后一个位置
2. 删除节点：删除的是处于堆 顶的节点
3. 构建二叉堆：把一个无序的完全二叉树调整为二叉堆，本质就是
让所有非叶子节点依次“下沉”

二叉堆的自我调整：把一个不符合堆性质的完全二叉树，调整成一个堆。

二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组中。

### 图
### 其他
跳表、哈希链表、位图