### 字节码文件
[JVM 规范文档](https://docs.oracle.com/javase/specs/jvms/se16/html/index.html)
>文件魔数：每个class文件的头4个字节称为魔数(Magic Number)，其值为：0xCAFEBABE，它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的class文件。使用魔数而不是扩展名来进行识别主要是基于安全的考虑，因为文件的扩展名可以随意地被改动。

javap 命令对 .class 文件进行反编译
```
javap -v helle.class
```
可以配合字节码学习 JVM 相关命令、内部类、泛型、sychronized 关键字

### JVM 运行时数据区
- 被所有线程共享
    - 堆
    - 方法区
    - 运行时常量池
- 所有线程私有的
    - 本地方法栈
    - 虚拟机栈
    - 程序计数器

#### 虚拟机栈中的栈帧
- 局部变量表
- 操作数栈
- 动态链接
- 返回地址

#### 堆中对象结构
- 对象头
    - MarkWorld
    - 类型指针
    - 数组长度（对象是数组事）
- 具体数据
- 对齐填充

### 垃圾回收
#### JVM 堆的结构划分
- 新生代
    - eden（80%）
    - from（10%）
    - to（10%）
- 老年代

对象会在新⽣代的 eden 区域中创建（⼤对象会直接进⼊⽼年代），第⼀次 eden 区满了以后进⾏ minor GC 将存储对象 age + 1，然后放⼊ from 区域，将 eden 区域内存清空。以后每次 minor GC 都将 eden 和 from 中的存活对象 age + 1，然后放⼊ to 区域，然后将 to区域和 from 区域互相调换。

在 age 达到⼀定值时会移动到⽼年代。

在 minor GC 时，存活对象⼤于 to区域，那么会直接进⼊⽼年代。
#### 垃圾回收算法
- 标记-清除算法（会产生空闲内存碎片）
- 标记-整理算法（防止产生内存碎片）
- 复制算法（效率最高，但是内存使用率低）
>新生代中使用复制算法，老年代使用标记整理算法
#### 关于跨代引用
为了防⽌不能确定新⽣代的对象是否被⽼年代的对象引⽤⽽需要进⾏ full GC。

通过 card table 将⽼年代分成若⼲个区域，所以在 minor GC 时只需要对表中记录的⽼年代区域进⾏扫描就可以了。